<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      三种最短路径算法综述 | UncleMask`s Laboratory 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="UncleMask">
    
    

    <meta name="description" content="从雪晴大佬那里转载来的，虽然不太懂，但只要低头就可以了。ORZ(天依蓝)  1.最短路径算法介绍问题解释：从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径解决问题的算法：Floyd算法Dijkstra算法SPFA算法2.Floyd算法弗洛伊德算法是解决任意两点间的最短路径的一种算法，可以正确处理有向图或有向图或负权的最短路径问题，同时也被用于计算有向图的">
<meta name="keywords" content="算法,模板,图论">
<meta property="og:type" content="article">
<meta property="og:title" content="三种最短路径算法综述 | UncleMask`s Laboratory">
<meta property="og:url" content="http://yoursite.com/2018/01/16/2018-1-16-ZDLJ/index.html">
<meta property="og:site_name" content="UncleMask`s Laboratory">
<meta property="og:description" content="从雪晴大佬那里转载来的，虽然不太懂，但只要低头就可以了。ORZ(天依蓝)  1.最短路径算法介绍问题解释：从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径解决问题的算法：Floyd算法Dijkstra算法SPFA算法2.Floyd算法弗洛伊德算法是解决任意两点间的最短路径的一种算法，可以正确处理有向图或有向图或负权的最短路径问题，同时也被用于计算有向图的">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-01-22T06:03:07.584Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="三种最短路径算法综述 | UncleMask`s Laboratory">
<meta name="twitter:description" content="从雪晴大佬那里转载来的，虽然不太懂，但只要低头就可以了。ORZ(天依蓝)  1.最短路径算法介绍问题解释：从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径解决问题的算法：Floyd算法Dijkstra算法SPFA算法2.Floyd算法弗洛伊德算法是解决任意两点间的最短路径的一种算法，可以正确处理有向图或有向图或负权的最短路径问题，同时也被用于计算有向图的">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="../../../../css/uno.css">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link rel="stylesheet" href="../../../../css/archive.css">
    <link rel="stylesheet" href="../../../../css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">UncleMask`s Laboratory</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          Just Do What You Want
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">统计</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



<nav class="cover-navigation navigation--social">
  <ul class="navigation">

    
      <!-- Qzone -->
      <li class="navigation__item">
        <a href="https://user.qzone.qq.com/934560304" title="Huno on Qzone">
          <i class='icon cs-icon-qzone'></i>
          <span class="label">Qzone</span>
        </a>
      </li>
    


    
    <!-- China social icon -->
    <!--
    
      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-douban'></i>
          <span class="label">Douban</span>
        </a>
      </li>

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-weibo'></i>
          <span class="label">Weibo</span>
        </a>
      </li>

    -->



  </ul>
</nav>



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">三种最短路径算法综述</h1>

    

    <div class="post-meta">
      <time datetime="2018-01-16" class="post-meta__date date">2018-01-16</time> 

      <span class="post-meta__tagss tags">

          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="../../../../categories/计算机/">计算机</a>, <a class="categories-link" href="../../../../categories/计算机/膜晴/">膜晴</a>
            </font>
          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="../../../../tags/图论/">图论</a>, <a class="tags-link" href="../../../../tags/模板/">模板</a>, <a class="tags-link" href="../../../../tags/算法/">算法</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <section id="post-content" class="article-content post"><br>    <p><font color="#66ccff" face="黑体">从雪晴大佬那里转载来的，虽然不太懂，但只要低头就可以了。ORZ(天依蓝)  </font></p><br><div class="post-body" itemprop="articleBody" style="opacity: 1; display: block; transform: translateY(0px);"><br><a name="sidebar-toc-Ik4D-0" id="sidebar-toc-Ik4D-0"></a><h1 id="1-最短路径算法介绍"><a href="#1-最短路径算法介绍" class="headerlink" title="1.最短路径算法介绍"></a>1.最短路径算法介绍</h1><p>问题解释：<br>从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径</p><br><p>解决问题的算法：</p><br><ul><br><li>Floyd算法</li><br><li>Dijkstra算法</li><br><li>SPFA算法</li><br></ul><br><a name="sidebar-toc-Ik4D-1" id="sidebar-toc-Ik4D-1"></a><h1 id="2-Floyd算法"><a href="#2-Floyd算法" class="headerlink" title="2.Floyd算法"></a>2.Floyd算法</h1><p>弗洛伊德算法是解决任意两点间的最短路径的一种算法，可以正确处理有向图或有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。</p><br><hr><br><p>假设图中顶点个数为N，则需要对二维数组a进行N次更新。更新前，a[i][j]代表从顶点i到顶点j的距离，如果i和j不相邻则a[i][j]=∞，顶点b[i][j]则为j的值。接下来对数组a进行N次更新。第一次更新时，取第一个点为中介点，则i——①——j的距离可以表示为a[i][1]+a[1][j],<br>如果这个值小于a[i][j]，就把a[i][j]的值更新为a[i][1]+a[1][j]，<br>。同理，第k次更新时，如果 a[i][j] &gt; a[i][k]+a[k][j] ，就更新a[i][j]=a[i][k]+a[k][j]</p><br><ul><br><li>贴个代码<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#define N 999999</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    int n,m;</span><br><span class="line">    int point1,point2,dis;</span><br><span class="line">    int a[100][100];</span><br><span class="line">    memset(a,N,sizeof(a));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m; //n 顶点个数，m 边数</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        a[i][i]=0;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">    {</span><br><span class="line">        cin&gt;&gt;point1&gt;&gt;point2&gt;&gt;dis;</span><br><span class="line">        a[point1][point2]=dis;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for(int k=1;k&lt;=n;k++)</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            for(int j=1;j&lt;=n;j++)</span><br><span class="line">                if(a[i][j]&gt;a[i][k]+a[k][j])</span><br><span class="line">                    a[i][j]=a[i][k]+a[k][j];</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    {</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            cout&lt;&lt;a[i][j]&lt;&lt;’ ‘;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br></li><br></ul><br><a name="sidebar-toc-Ik4D-2" id="sidebar-toc-Ik4D-2"></a><h1 id="3-Dijkstra算法"><a href="#3-Dijkstra算法" class="headerlink" title="3.Dijkstra算法"></a>3.Dijkstra算法</h1><a name="sidebar-toc-Ik4D-3" id="sidebar-toc-Ik4D-3"></a><h2 id="迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单元最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。"><a href="#迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单元最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。" class="headerlink" title="迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单元最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。"></a>迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单元最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</h2><p>Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。<br>然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点。<br>然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。<br>然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。<br>（不会贴图 先不贴了</p><br><ul><br><li>下面是代码 （算法部分<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void Dijk()//我们这里起点为1号编码点。我们这里的d[]表示从起点到这个点需要的权值。w[a][b]表示点a到点b这条边的权值.</span><br><span class="line">{</span><br><span class="line">    int  v, tmp;</span><br><span class="line">    memset(vis, 0, sizeof(vis));</span><br><span class="line">    for (int i=1; i&lt;=n; i++)</span><br><span class="line">        d[i] = w[1][i];//对于起点的初始化</span><br><span class="line">    d[1] = 0;</span><br><span class="line">    vis[1] = 1;</span><br><span class="line">    for (int i=1; i&lt;=n; i++)//控制连接点的次数，例如上图，九个点，就循环九次。</span><br><span class="line">    {</span><br><span class="line">        tmp = N;//这里N表示无穷大。</span><br><span class="line">        for (int j=1; j&lt;=n; j++)</span><br><span class="line">        {</span><br><span class="line">            if (tmp&gt;d[j] &amp;&amp; !vis[j])</span><br><span class="line">            {</span><br><span class="line">                tmp = d[j];</span><br><span class="line">                v = j;</span><br><span class="line">            }</span><br><span class="line">        }//每次我们都找到距离起点最近的点v</span><br><span class="line">        vis[v] = 1;</span><br><span class="line">        for (int k=1; k&lt;=n; k++)</span><br><span class="line">        {</span><br><span class="line">            if(!vis[k])</span><br><span class="line">                d[k]=min(d[k],d[v]+w[v][k]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br></li><br></ul><br><a name="sidebar-toc-Ik4D-4" id="sidebar-toc-Ik4D-4"></a><h1 id="3-SPFA算法"><a href="#3-SPFA算法" class="headerlink" title="3.SPFA算法"></a>3.SPFA算法</h1><a name="sidebar-toc-Ik4D-5" id="sidebar-toc-Ik4D-5"></a><h2 id="SPFA算法是求解单源最短路径问题的一种算法，由理查德·贝尔曼（Richard-Bellman）-和-莱斯特·福特-创立的。有时候这种算法也被称为-Moore-Bellman-Ford-算法，因为-Edward-F-Moore-也为这个算法的发展做出了贡献。它的原理是对图进行V-1次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达-O-VE-。但算法可以进行若干种优化，提高了效率。"><a href="#SPFA算法是求解单源最短路径问题的一种算法，由理查德·贝尔曼（Richard-Bellman）-和-莱斯特·福特-创立的。有时候这种算法也被称为-Moore-Bellman-Ford-算法，因为-Edward-F-Moore-也为这个算法的发展做出了贡献。它的原理是对图进行V-1次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达-O-VE-。但算法可以进行若干种优化，提高了效率。" class="headerlink" title="SPFA算法是求解单源最短路径问题的一种算法，由理查德·贝尔曼（Richard Bellman） 和 莱斯特·福特 创立的。有时候这种算法也被称为 Moore-Bellman-Ford 算法，因为 Edward F. Moore 也为这个算法的发展做出了贡献。它的原理是对图进行V-1次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达 O(VE)。但算法可以进行若干种优化，提高了效率。"></a>SPFA算法是求解单源最短路径问题的一种算法，由理查德·贝尔曼（Richard Bellman） 和 莱斯特·福特 创立的。有时候这种算法也被称为 Moore-Bellman-Ford 算法，因为 Edward F. Moore 也为这个算法的发展做出了贡献。它的原理是对图进行V-1次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达 O(VE)。但算法可以进行若干种优化，提高了效率。</h2><p>我们用数组dis记录每个结点的最短路径估计值，用邻接表或邻接矩阵来存储图G。我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止<br>我们要知道带有负环的图是没有最短路径的，所以我们在执行算法的时候，要判断图是否带有负环，方法有两种：</p><br><ol><br><li>开始算法前，调用拓扑排序进行判断（较为费时）</li><br><li>如果某个点进入队列的次数超过N次则存在负环（N为图的顶点数）</li><br></ol><br><p>(还没学完，学完再补坑</p><br><br><br>    </div><br>  </section>
  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    <!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js"></script>
<!-- UY END -->
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112385601-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-112385601-1');
</script>

    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
