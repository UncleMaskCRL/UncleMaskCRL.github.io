{"meta":{"title":"UncleMask`s Laboratory","subtitle":"Just Do What You Want","description":"这里面什么都有，就是没有有用的东西","author":"UncleMask","url":"http://yoursite.com"},"pages":[{"title":"统计","date":"2018-01-15T07:11:26.506Z","updated":"2018-01-15T07:11:26.506Z","comments":true,"path":"archive/index.html","permalink":"http://yoursite.com/archive/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-01-15T04:53:41.000Z","updated":"2018-01-15T07:21:36.390Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这里是一条化学🐶+程序🐒的站点。高中的时候学过两科竞赛，上了大学毅然决然地选择了化学专业，之前在樊院长手下干活，现已经转入李老师名下，现阶段最大的梦想就是能在一个不算特别low的期刊上发一篇自己为第一作者的论文，走出自化学竞赛以来的低谷，并且狠狠地打一下那些不认同我的人的脸 在大一社团招人的时候，由于还是对计算机以及算法的恋恋不舍，从而加入了“计算机精英协会”，在脱发的路上渐行渐远。目标是2018 ACM 和两个大佬队友成功挺进线下赛，并且保铜争银，也算是不辜负奥维休学一年的付出了，"},{"title":"categories","date":"2015-10-19T22:49:50.000Z","updated":"2018-01-15T06:44:34.949Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"三种最短路径算法综述","slug":"18-1-16-ZDLJ","date":"2018-01-16T02:56:31.000Z","updated":"2018-01-16T03:07:51.115Z","comments":true,"path":"2018/01/16/18-1-16-ZDLJ/","link":"","permalink":"http://yoursite.com/2018/01/16/18-1-16-ZDLJ/","excerpt":"","text":"从雪晴大佬那里转载来的，虽然不太懂，但只要低头就可以了。ORZ 1.最短路径算法介绍问题解释：从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径解决问题的算法：Floyd算法Dijkstra算法SPFA算法2.Floyd算法弗洛伊德算法是解决任意两点间的最短路径的一种算法，可以正确处理有向图或有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。假设图中顶点个数为N，则需要对二维数组a进行N次更新。更新前，a[i][j]代表从顶点i到顶点j的距离，如果i和j不相邻则a[i][j]=∞，顶点b[i][j]则为j的值。接下来对数组a进行N次更新。第一次更新时，取第一个点为中介点，则i——①——j的距离可以表示为a[i][1]+a[1][j],如果这个值小于a[i][j]，就把a[i][j]的值更新为a[i][1]+a[1][j]，。同理，第k次更新时，如果 a[i][j] &gt; a[i][k]+a[k][j] ，就更新a[i][j]=a[i][k]+a[k][j]贴个代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstring&gt;#define N 999999using namespace std;int main(){ int n,m; int point1,point2,dis; int a[100][100]; memset(a,N,sizeof(a)); cin&gt;&gt;n&gt;&gt;m; //n 顶点个数，m 边数 for(int i=1;i&lt;=n;i++) a[i][i]=0; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;point1&gt;&gt;point2&gt;&gt;dis; a[point1][point2]=dis; } for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(a[i][j]&gt;a[i][k]+a[k][j]) a[i][j]=a[i][k]+a[k][j]; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) cout&lt;&lt;a[i][j]&lt;&lt;’ ‘; cout&lt;&lt;endl; } return 0;}3.Dijkstra算法迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单元最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点。然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。（不会贴图 先不贴了下面是代码 （算法部分123456789101112131415161718192021222324252627void Dijk()//我们这里起点为1号编码点。我们这里的d[]表示从起点到这个点需要的权值。w[a][b]表示点a到点b这条边的权值.{ int v, tmp; memset(vis, 0, sizeof(vis)); for (int i=1; i&lt;=n; i++) d[i] = w[1][i];//对于起点的初始化 d[1] = 0; vis[1] = 1; for (int i=1; i&lt;=n; i++)//控制连接点的次数，例如上图，九个点，就循环九次。 { tmp = N;//这里N表示无穷大。 for (int j=1; j&lt;=n; j++) { if (tmp&gt;d[j] &amp;&amp; !vis[j]) { tmp = d[j]; v = j; } }//每次我们都找到距离起点最近的点v vis[v] = 1; for (int k=1; k&lt;=n; k++) { if(!vis[k]) d[k]=min(d[k],d[v]+w[v][k]); } }}3.SPFA算法SPFA算法是求解单源最短路径问题的一种算法，由理查德·贝尔曼（Richard Bellman） 和 莱斯特·福特 创立的。有时候这种算法也被称为 Moore-Bellman-Ford 算法，因为 Edward F. Moore 也为这个算法的发展做出了贡献。它的原理是对图进行V-1次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达 O(VE)。但算法可以进行若干种优化，提高了效率。我们用数组dis记录每个结点的最短路径估计值，用邻接表或邻接矩阵来存储图G。我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止我们要知道带有负环的图是没有最短路径的，所以我们在执行算法的时候，要判断图是否带有负环，方法有两种：开始算法前，调用拓扑排序进行判断（较为费时）如果某个点进入队列的次数超过N次则存在负环（N为图的顶点数）(还没学完，学完再补坑","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"膜晴","slug":"计算机/膜晴","permalink":"http://yoursite.com/categories/计算机/膜晴/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"后处理方法简单汇总","slug":"18-1-15-HCL","date":"2018-01-15T08:18:41.000Z","updated":"2018-01-16T03:09:10.030Z","comments":true,"path":"2018/01/15/18-1-15-HCL/","link":"","permalink":"http://yoursite.com/2018/01/15/18-1-15-HCL/","excerpt":"","text":"有机酸碱性化合物的分离提纯 具有酸碱性基团的有机化合物，可以得失质子形成离子化合物，而离子化合物与原来的母体化合物具有不同的物理化学性质。碱性化合物用有机酸或无机酸处理得到胺盐，酸性化合物用有机碱或无机碱处理得到钠盐或有机盐。根据有机化合物酸碱性的强弱，有机、无机酸碱一般为甲酸、乙酸、盐酸、硫酸、磷酸。碱为三乙胺、氢氧化钠、氢氧化钾、碳酸钠、碳酸氢钠等。在一般情况下，离子化合物在水中具有相当大的溶解性，而在有机溶剂中溶解度很小，同时活性碳只能够吸附非离子型的杂质和色素。利用以上的这些性质可对酸碱性有机化合物进行提纯。以上性质对所有酸碱性化合物并不通用，一般情况下，分子中酸碱性基团分子量所占整个分子的分子量比例越大，则离子化合物的水溶性就越大，分子中含有的水溶性基团例如羟基越多，则水溶性越大，因此，以上性质适用于小分子的酸碱化合物。对于大分子的化合物，则水溶性就明显降低。 酸碱性基团包括氨基。酸性基团包括：酰氨基、羧基、酚羟基、磺酰氨基、硫酚基、1，3－二羰基化合物等等。值得注意的是，氨基化合物一般为碱性基团，但是在连有强吸电子基团时就变为酸性化合物，例如酰氨基和磺酰氨基化合物，这类化合物在氢氧化钠、氢氧化钾等碱作用下就容易失去质子而形成钠盐。 中合吸附法：将酸碱性化合物转变为离子化合物，使其溶于水，用活性碳吸附杂质后过滤，则除去了不含酸碱性基团的杂质和机械杂质，再加酸碱中合回母体分子状态，这是回收和提纯酸碱性产品的方法。由于活性碳不吸附离子，故有活性碳吸附造成的产品损失忽劣不计。 中和萃取法：是工业过程和实验室中常见的方法，它利用酸碱性有机化合物生成离子时溶于水而母体分子状态溶于有机溶剂的特点，通过加入酸碱使母体化合物生成离子溶于水实现相的转移而用非水溶性的有机溶剂萃取非酸碱性杂质，使其溶于有机溶剂从而实现杂质与产物分离的方法。 成盐法：对于非水溶性的大分子有机离子化合物，可使有机酸碱性化合物在有机溶剂中成盐析出结晶来，而非成盐的杂质依然留在有机溶剂中，从而实现有机酸碱性化合物与非酸碱性杂质分离，酸碱性有机杂质的分离可通过将析出的结晶再重结晶，从而将酸碱性有机杂质分离。对于大分子的有机酸碱化合物的盐此时还可以采用水洗涤除去小分子的酸碱化合物已经成盐且具有水溶性的杂质。 对于水溶性的有机离子化合物，可在水中成盐后，将水用共沸蒸馏或直接蒸馏除去，残余物用有机溶剂充分洗涤几次，从而将杂质与产品分离。以上三种方法并不是孤立的，可根据化合物的性质和产品质量标准的要求，采用相结合的方法，尽量得到相当纯度的产品。 几种特殊的有机萃取溶剂 正丁醇：大多数的小分子醇是水溶性的，例如甲醇、乙醇、异丙醇、正丙醇等。大多数的高分子量醇是非水溶性的，而是亲脂性的能够溶于有机溶剂。但是中间的醇类溶剂例如正丁醇是一个很好的有机萃取溶剂。正丁醇本身不溶于水，同时又具有小分子醇和大分子醇的共同特点。它能够溶解一些能够用小分子醇溶解的极性化合物，而同时又不溶于水。利用这个性质可以采用正丁醇从水溶液中萃取极性的反应产物 丁酮：性质介于小分子酮和大分子酮之间。不像丙酮能够溶于水，丁酮不溶于水，可用来从水中萃取产物 乙酸丁酯：性质介于小分子和大分子酯之间，在水中的溶解度极小，不像乙酸乙酯在水中有一定的溶解度，可从水中萃取有机化合物，尤其是氨基酸的化合物，因此在抗生素工业中常用来萃取头孢、青霉素等大分子含氨基酸的化合物 异丙醚与特丁基叔丁基醚：性质介于小分子和大分子醚之间，两者的极性相对较小，类似于正己烷和石油醚，二者在水中的溶解度较小。可用于极性非常小的分子的结晶溶剂和萃取溶剂。也可用于极性较大的化合物的结晶和萃取溶剂。 做完反应后，应该首先采用萃取的方法，首先除去一部分杂质，这是利用杂质与产物在不同溶剂中的溶解度不同的性质 稀酸的水溶液洗去一部分碱性杂质。例如，反应物为碱性，而产物为中性，可用稀酸洗去碱性反应物。例如胺基化合物的酰化反应。 稀碱的水溶液洗去一部分酸性杂质。反应物为酸性，而产物为中性，可用稀碱洗去酸性反应物。例如羧基化合物的酯化反应。 用水洗去一部分水溶性杂质。例如，低级醇的酯化反应，可用水洗去水溶性的反应物醇。 如果产物要从水中结晶出来，且在水溶液中的溶解度又较大，可尝试加入氯化钠、氯化铵等无机盐，降低产物在水溶液中的溶解度－盐析的方法。 有时可用两种不互溶的有机溶剂作为萃取剂，例如反应在氯仿中进行，可用石油醚或正己烷作为萃取剂来除去一部分极性小的杂质，反过来可用氯仿萃取来除去极性大的杂质。 两种互溶的溶剂有时加入另外一种物质可变的互不相容，例如，在水作溶剂的情况下，反应完毕后，可往体系中加入无机盐氯化钠，氯化钾使水饱和，此时加入丙酮，乙醇，乙腈等溶剂可将产物从水中提取出来。 结晶与重结晶的方法 基本原理是利用相似相容原理。即极性强的化合物用极性溶剂重结晶，极性弱的化合物用非极性溶剂重结晶。对于较难结晶的化合物，例如油状物、胶状物等有时采用混合溶剂的方法，但是混合溶剂的搭配很有学问，有时只能根据经验。一般采用极性溶剂与非极性溶剂搭配，搭配的原则一般根据产物与杂质的极性大小来选择极性溶剂与非极性溶剂的比例。若产物极性较大，杂质极性较小则溶剂中极性溶剂的比例大于非极性溶剂的比例；若产物极性较小，杂质极性较大，则溶剂中非极性溶剂的比例大于极性溶剂的比例。较常用的搭配有：醇－石油醚，丙酮－石油醚，醇－正己烷，丙酮－正己烷等。但是如果产物很不纯或者杂质与产物的性质及其相近，得到纯化合物的代价就是多次的重结晶，有时经多次也提不纯。这时一般较难除去的杂质肯定与产物的性质与极性及其相近。除去杂质只能从反应上去考虑了。 水蒸气蒸馏、减压蒸馏与精馏的方法 这是提纯低熔点化合物的常用方法。一般情况下，减压蒸馏的回收率相应较低，这是因为随着产品的不断蒸出，产品的浓度逐渐降低，要保证产品的饱和蒸汽压等于外压，必须不断提高温度，以增加产品的饱和蒸汽压，显然，温度不可能无限提高，即产品的饱和蒸汽压不可能为零，也即产品不可能蒸净，必有一定量的产品留在蒸馏设备内被设备内的难挥发组分溶解，大量的斧残既是证明。 共沸蒸馏不仅适用于产品分离过程，也适用于反应物系的脱水、溶剂的脱水、产品的脱水等。它比分子筛、无机盐脱水工艺具有设备简单、操作容易、不消耗其它原材料等优点。例如：在生产氨噻肟酸时，由于分子中存在几个极性的基团氨基、羧基等，它们能够和水、醇等分子形成氢键，使氨噻肟酸中存在大量的游离及氢键的水，如采用一般的真空干燥等干燥方法，不仅费时，也容易造成产物的分解，这时可采用共沸蒸馏的方法将水分子除去，具体的操作为将氨噻肟酸与甲醇在回流下搅拌几小时，可将水分子除去，而得到无水氨噻肟酸。又比如，当分子中存在游离的或氢键的甲醇时，可用另外一种溶剂，例如正己烷、石油醚等等，进行回流，可除去甲醇。可见共沸蒸馏在有机合成的分离过程中占有重要的地位。 超分子的方法，利用分子的识别性来提纯产物 脱色的方法 一般采用活性炭、硅胶、氧化铝等。活性炭吸附非极性的化合物与小分子的化合物，硅胶与氧化铝吸附极性强的与大分子的化合物，例如焦油等。对于极性杂质与非极性杂质同时存在的物系，应将两者同时结合起来。比较难脱色的物系，一般用硅胶和氧化铝就能脱去。对于酸碱性化合物的脱色，有时比较难，当将酸性化合物用碱中和形成离子化合物而溶于水中进行脱色时，除了在弱碱性条件下脱色一次除去碱性杂质外，还应将物系逐渐中和至弱酸性，再脱色一次除去酸性杂质，这样就将色素能够完全脱去。同样当将碱性化合物用酸中和至弱碱性溶于水进行脱色时，除了在弱酸性条件下脱色一次除去酸性杂质外，还应将物系逐渐中和至弱碱性，再脱色一次除去碱性杂质。","categories":[{"name":"化学","slug":"化学","permalink":"http://yoursite.com/categories/化学/"}],"tags":[{"name":"后处理","slug":"后处理","permalink":"http://yoursite.com/tags/后处理/"},{"name":"实验操作","slug":"实验操作","permalink":"http://yoursite.com/tags/实验操作/"}]},{"title":"BST(二叉搜索树)","slug":"18-1-15-BST","date":"2018-01-15T05:09:54.000Z","updated":"2018-01-16T03:08:18.625Z","comments":true,"path":"2018/01/15/18-1-15-BST/","link":"","permalink":"http://yoursite.com/2018/01/15/18-1-15-BST/","excerpt":"","text":"二叉搜索树是一种树的类型。它的左子树若不为空，则其中所有节点的值都必定小于父节点；同理若它的右子树不为空，其中所有的节点也必定大于父节点。如下所示，12的左子树的节点数值全部比12小，右子树节点的数值全部比12大。 构造二叉搜索树针对于构造二叉搜索树，先确定其根节点，后进行如下操作 比较节点(root)与待插入值的大小：若root较大，则将root赋值为该节点的左子节点；若root较小，则将root赋值为该节点的右子节点。 若该节点没有的左(右)子节点为0，也就是没有子节点。那么将此待插入值定义为root的子节点。 搜索二叉搜索树因为二叉搜索树一定满足上面提到的条件，故而在搜索时应先比较大小，若小于当前节点则向它的左子树去搜索，若大于当前节点则向它的右子树去搜索，直到当前节点等于我们要找的节点。 相关题目HDOJ 5444","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"原创","slug":"计算机/原创","permalink":"http://yoursite.com/categories/计算机/原创/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-15T02:18:16.970Z","updated":"2018-01-15T06:49:11.099Z","comments":true,"path":"2018/01/15/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}