{"meta":{"title":"UncleMask`s Laboratory","subtitle":"Just Do What You Want","description":"这里面什么都有，就是没有有用的东西","author":"UncleMask","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2018-01-15T04:53:41.000Z","updated":"2018-02-01T05:03:42.838Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这里是一条化学🐶+程序🐒的博客。事先说明，虽然有些东西写的是原创，但其实还是根据别人的东西再进行二次加工而得到的。只是为了给自己搭建一个关于算法和计算机的相关知识体系罢了。我将会尽可能的把我学到的东西放在上面，对算法和化学科研有兴趣的人可以随时来看，并欢迎指正错误和不足。"},{"title":"统计","date":"2018-01-15T07:11:26.506Z","updated":"2018-01-15T07:11:26.506Z","comments":true,"path":"archive/index.html","permalink":"http://yoursite.com/archive/index.html","excerpt":"","text":""},{"title":"categories","date":"2015-10-19T22:49:50.000Z","updated":"2018-01-15T06:44:34.949Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"LCA问题的RMQ与倍增解法","slug":"18-2-1-LCA","date":"2018-02-01T02:14:25.000Z","updated":"2018-02-01T04:58:50.496Z","comments":true,"path":"2018/02/01/18-2-1-LCA/","link":"","permalink":"http://yoursite.com/2018/02/01/18-2-1-LCA/","excerpt":"","text":"LCA(Least Common Ancestors)，最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。比如在这场图中3和5的最近公共祖先就是2，5和6的最近公共祖先就是4，1和2的最近公共祖先是1 等。 暴力若两个节点分别是u,v，首先将其中一个较深的点向上跳，跳到同一高度后两个点一起跳，直到跳到同一个点，这个点即为他们的LCA。这种方法最直接，但复杂度过高，实际做的时候一定会TLE。 倍增寻找这种方法是暴力解法的一种优化，首先是记录每一个点往上跳\\(2 ^ j\\)步后的点，这一步骤可以通过DP来实现。每个点向上跳\\(2 ^ 0\\)个点后的点都是他们的父节点，另外通过\\(2 ^ j = 2 ^ {j - 1} + 2 ^ {j - 1}\\)可知，i的\\(2^j\\)祖先就是i的\\(2^{j-1}\\)祖先的\\(2^{j-1}\\)祖先，故而\\(p[i][j]=p[p[i][j-1]][j-1]\\)。然后得到了p数组之后，通过记录的深度d计算出可以跳的最大的j，也就是\\([log_2 d]+1\\)（向上取整）。从j的最大值向下迭代，若此时的\\(p[u][j] != p[v][j]\\)则一起向上跳\\(2^j\\)个点，如此循环，直到结束。核心代码如下：1234567891011121314151617181920212223int lca(int u, int v)&#123; if (d[u] &lt; d[v]) swap(u, v); //我们希望u是较深的点。 for (int i = jmax; i &gt;= 0; i--) //这个循环在完成第一步。 &#123; if (d[v] &lt;= d[p[u][i]]) //不可以丢掉“=“哦 &#123; u = p[u][i]; &#125; &#125; if (u == v) return u; //如果v是u的祖先，就可以直接返回结果了。 for (int i = jmax; i &gt;= 0; i--) &#123; if (p[u][i] != p[v][i]) //第二步。 &#123; u = p[u][i]; v = p[v][i]; &#125; &#125; return p[u][0];&#125; RMQ+时间戳对于时间戳这个概念我也是第一次见，简单来说就是一个树被dps时的访问顺序。在这个树中DFS遍历序列就是1 2 3 2 4 2 5 2 1 6 7 8 7 6 1。很多点被访问了不止一次。很容易想到，对于任意两个点，从一个点到另一个点，进行dfs时必定要经过它的LCA。比如4和6，遍历大致顺序为1 2 4 2 1 6，从4到6的过程中就回到了他们的LCA也就是1。所以如果一个树的编号是以先序遍历的方式来编号的话可以先通过dps整个树来得到一串时间戳，然后再查找两个点之间的那串时间戳中最小的点，那个点即为两点的LCA。其中查找的过程可以用RMQ来解决，复杂度较低。对于这种方法局限性较大，不过代码很方便，可以视情况使用。&nbsp;上面两种方法都算是在线查找的方案，其实还有一种Tarjan算法，是离线的，可以通过遍历一次树即可得到所有的结果，之后会有一篇blog专门写这部分。 重要结论对于LCA来说他目前可以用到的最大的用处就是计算树上任意两点的距离。若树上两点(u,v)的路径长度为Long[u,v]，long[i]表示i到root的长度，则\\(Long[u,v] = long[u]+long[v]-2*long[lca(u,v)]\\) 相关例题HDOJ2586","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"原创","slug":"计算机/原创","permalink":"http://yoursite.com/categories/计算机/原创/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"RMQ问题ST算法解决方案","slug":"18-1-26-RMQ","date":"2018-01-26T12:13:35.000Z","updated":"2018-02-01T02:17:50.582Z","comments":true,"path":"2018/01/26/18-1-26-RMQ/","link":"","permalink":"http://yoursite.com/2018/01/26/18-1-26-RMQ/","excerpt":"","text":"对于我开了这个问题的坑这件事我表示非常后悔，因为由这个问题我又学到了LCA问题的几种解决方法，其中有一种叫做Tarjan算法的又是一个大坑。所以由The Water Problem引申出的这些问题，我将会陆续写三篇blog来解决所有问题。&nbsp;RMQ问题，简单来说就是对于一组数据查找某段数字中的最大或最小值，为了表述方便之后都以最大值为例。首先规定\\(F[i,j]\\)表示从第i个数起连续\\(2^j\\)个数中的最大值。例如：A数列为：3 2 4 5 6 8 1 2 9 7\\(F[1,0]\\)表示第1个数起，长度为\\(2^0\\)=1的最大值，其实就是3这个数。同理 \\(F[1,1]\\) = max(3,2) = 3, \\(F[1，2]\\) =max(3,2,4,5) = 5，\\(F[1，3]\\) = max(3,2,4,5,6,8,1,2) = 8。而且很容易发现\\(F[i,0]\\) = A[i]。而整体就是一个DP过程，经过简单的观察可得到\\(F[i,j]=max(F[i,j - 1], F[i + 2^{j-1},j-1])\\)。&nbsp;接下来就是查询的过程，假如我们需要查询的区间为(p,q)，那么我们需要找到覆盖这个闭区间的最小幂（可以重复，比如查询1，2，3，4，5，我们可以查询1234和2345）。因为这个区间的长度为q-p+1,所以我们可以取k=\\(log_2 (q - p + 1)\\)，则有：\\(RMQ(p, q)=max(F[p,k], F[q - 2 ^ k + 1,k])\\)。举例说明，要求区间[1，5]的最大值，k =\\(log_2 (5 - 1 + 1)\\) = 2，即求\\(max(F[1, 2]，F[5 - 2 ^ 2 + 1, 2])=max(F[1, 2]，F[2, 2])\\)；算法实现如下：1234567891011121314void ST(int n) &#123; for (int i = 1; i &lt;= n; i++) dp[i][0] = A[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) &#123; dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125; &#125; int RMQ(int l, int r) &#123; int k = 0; while ((1 &lt;&lt; (k + 1)) &lt;= r - l + 1) k++; return min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]); &#125; 相关例题HD5443(史上最良心标题)","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"原创","slug":"计算机/原创","permalink":"http://yoursite.com/categories/计算机/原创/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"建模相关资料","slug":"18-1-26-MGJM","date":"2018-01-26T08:08:11.000Z","updated":"2018-02-01T02:18:44.376Z","comments":true,"path":"2018/01/26/18-1-26-MGJM/","link":"","permalink":"http://yoursite.com/2018/01/26/18-1-26-MGJM/","excerpt":"","text":"2018年美赛的举办时间为北京时间2月9日6点至2月13日9点，共99小时。和ACM纯粹是高智商人群的玩具不同，建模竞赛的特点是有广度而欠缺深度，因此在竞赛过程中遇到之前从未见过的模型也是很正常的，所以除去建立模型的硬实力以外搜索、阅读、快速自学能力也是重点。最常见的几类题型分别是：优化、预测、分类、评价。而对于我们将会主要解决的C题会用到的知识是插值、拟合、回归、标准化、降维。 规划and优化0-1规划、线性规划、整数规划、非线性规划、动态规划、单目标规划、多目标规划推荐使用Lingo和Matlab 分类聚类分析：K-means算法判别分析：Fisher判别法、Bayes判别法模糊聚类神经网络分类支持向量机（SVM） 评价层次分析法、综合评分法、综合指数法、Topsis法、秩和比法 预测时间序列、灰色预测、模糊预测、神经网络预测 图论最短路径、指派问题、Hmilton圈、旅行商TSP问题、最小生成树、网络最大流、最小费用流 论文是建模竞赛中最重要的部分，其中画图和摘要是重中之重。望周知 美赛的评阅过程一般分为三个阶段。首先是初评，重点看摘要，预览一下整篇文章；然后是甄别，主要考察模型，清晰模型和坚实分析可得较高分，分析、结果和写作的一致性是重要的；最后是终评，目的是挑选优秀论文，比较细节。 所以再强调一遍，摘要真的真的真的非常重要。 假如这道题已经可以解决了，那么我们该如何从几千个队伍中脱颖而出呢。首先是模型，美赛和国赛不同，美赛可能会更看重你的创意，除去创意分你的模型最好选取更详细、具体的指标，并且与其他模型做横向比较，取长补短。另外是分析，这方面可能是主要跟其他队伍拉开档次的地方，想办法拓展，做的尽可能深入。对于一些非常抽象的指标只要有道理，随便怎么处理都可以，但是！！不考虑这些指标是大忌。最后结果分析非常重要，这是新手和老手之间的主要差别，如果一篇数模论文只有模型、求解、结果，并不算完整。只有加上结果分析才能算是一篇完整的论文。 链接：https://pan.baidu.com/s/1jJHQJX0 密码：adq8 密码请自己找一下吧，很显眼的。","categories":[{"name":"原创","slug":"原创","permalink":"http://yoursite.com/categories/原创/"}],"tags":[{"name":"建模","slug":"建模","permalink":"http://yoursite.com/tags/建模/"}]},{"title":"备忘录","slug":"2018-1-22-BWL","date":"2018-01-22T04:09:35.000Z","updated":"2018-01-31T12:04:10.938Z","comments":true,"path":"2018/01/22/2018-1-22-BWL/","link":"","permalink":"http://yoursite.com/2018/01/22/2018-1-22-BWL/","excerpt":"","text":"reflux——回流，一般根据溶剂的沸点而定，后通过是否有溶剂从冷凝管上滴下来调整温度。 酚形成金属盐时通常会有颜色，酚盐被反应掉后颜色会变浅，可以简单判断实验进程。 点板时若溶剂为DMF，由于DMF不挥发，需要先用其他溶剂混溶，后加入水，将DMF萃取入水中，经过三次如上操作，即可点板。 若加入其他溶剂时溶液是浑浊的，可能因为产物不溶于新加入的溶剂，也可能因为DMF中溶解了少量的离子盐，盐不溶于该溶剂。 板子的硅胶涂有荧光材料，在254nm上发绿光，板子上点上了东西荧光材料会被遮盖或发出更强的荧光。 爬板时展开剂极性太强会让点过高，因此要混入极性较弱的溶剂做展开剂。 羟基过多会让产物无法溶解于二氯甲烷。 用封管做反应时可比溶剂沸点高20°C左右，但用DMF做溶剂时体系温度一般不超过100°C，温度过高会使DMF分解。 选择展开剂以极性为准，一般使用石油醚和乙酸乙酯，因为这两种溶剂的溶解性不好，当产物的溶解性能不好时才使用二氯甲烷和甲醇。 使用紫外灯照射板子的时候一般以254nm的为准，365nm会看到很多奇奇怪怪的点。 经常会在各种体系出现随展开剂爬到头的点，在254nm的照射下有时会呈蓝紫色。 &nbsp;在上面的反应中很有可能会出现这样的副产物出现，从而使体系颜色变为橙色。这是因为氨是给电子基团，羧基是吸电子基团，一给一吸从而使整个化合物的吸收光波长变大50~100nm左右。假如原本是在紫外光区吸收的物质，本应是白色的，经过这样的影响之后可能会在可见光区有吸收。 紫外照射时会发生跃迁，化合物电子变为激发态，然而此时的激发态可能不是一个最稳定的激发状态，于是该物质会改变自己的结构，使能量适当降低变为最稳定的激发态结构。这也就是为什么吸收光谱和发射光谱不同的原因。激发的过程等同于在分子轨道理论中将电子从HOMO轨道激发到LOMO轨道的过程。HOMO和LOMO轨道能量差是不会变的，但之所以吸收和发射光谱不同其实还是因为化合物的结构改变了，物质都不相同能量差自然不同。降低激发态能量的手段比如有形成氢键。既然降低了能量，紫外照射时的颜色也就会有所不同。 对苯二酚类物质极易被氧化为苯醌类物质，所以体系颜色会变深，唯一的区别就是颜色的深浅罢了。 碱性条件下酯很容易水解，所以要用氯化铵溶液代替水，将其调至弱酸性。","categories":[{"name":"化学","slug":"化学","permalink":"http://yoursite.com/categories/化学/"}],"tags":[{"name":"实验记录","slug":"实验记录","permalink":"http://yoursite.com/tags/实验记录/"}]},{"title":"Wittig反应中的临溴效应","slug":"18-1-21-LXXY","date":"2018-01-21T15:09:26.000Z","updated":"2018-01-22T06:02:22.151Z","comments":true,"path":"2018/01/21/18-1-21-LXXY/","link":"","permalink":"http://yoursite.com/2018/01/21/18-1-21-LXXY/","excerpt":"","text":"在看文献的过程中发现了一个叫做临溴效应的东西，于是查了一下这篇参考文献。 Tetrahedron Letters 43 (2002) 2449–2453 主要研究的是临位卤素取代的苄基三苯基鏻盐2与临位卤素取代的苯甲醛3通过Wittig反应得到的产物1(Scheme 1)的Z/E取向比例与取代原子种类的关系。 Table 1 中是在室温环境下在50%NaOH的氢氧化钠水溶液的存在下2和3在氯仿中反应的结果。之所以可以用这么简单的两相反应介质是因为鏻盐本身就可以作为相转移催化剂使用。 从表中可以发现很多非常有趣的现象： 比对8,1,10,19，发现在3上连接一个卤素原子可以使Z型产物比例增加。 比对1/3,10/12,19/21，发现3上连接一个卤素原子的同时再在2上连接一个卤素原子可以使Z型产物比例再次增加。 比对8,2,11,20，发现在2上连接一个卤素原子可以使E型产物比例增加。 比对1/5,10/14,2/4,11/13，发现在同一个反应物上接上第二个卤素原子的时候，E型产物比例显著增加。 比对4/7,5/6,13/16,14/15，由于合作效应在接入第三个卤素原子的时候，Z型产物比例又再次增加。 由17可得，当所有位置都被卤素原子占据的时候，E型产物占主导地位。","categories":[{"name":"化学","slug":"化学","permalink":"http://yoursite.com/categories/化学/"}],"tags":[{"name":"文献","slug":"文献","permalink":"http://yoursite.com/tags/文献/"}]},{"title":"重结晶基础操作","slug":"18-1-20-CJJ","date":"2018-01-20T10:24:06.000Z","updated":"2018-01-20T10:54:45.911Z","comments":true,"path":"2018/01/20/18-1-20-CJJ/","link":"","permalink":"http://yoursite.com/2018/01/20/18-1-20-CJJ/","excerpt":"","text":"原理利用混合物中各组分在某种溶剂中的溶解度不同，或者在同一溶剂中不同温度时的溶解度不同，而使它们相互分离。 溶剂的选择我们从下面七个方面来选择溶剂： 常用溶剂： DMF、氯苯、二甲苯、甲苯、乙腈、乙醇、THF、氯仿、乙酸乙酯、环己烷、丁酮、丙酮、石油醚。 比较常用溶剂：DMSO、六甲基磷酰胺、N-甲基吡咯烷酮、苯、环己酮、丁酮、环己酮、二氯苯、吡啶、乙酸、二氧六环、乙二醇单甲醚、1,2-二氯乙烷、乙醚、正辛烷。 一个好的溶剂在沸点附近对待结晶物质溶解度高而在低温下溶解度又很小。DMF、苯、二氧六环、环己烷在低温下接近凝固点，溶解能力很差，是理想溶剂。乙腈、氯苯、二甲苯、甲苯、丁酮、乙醇也是理想溶剂。 溶剂的沸点最好比被结晶物质的熔点低50℃。否则易产生溶质液化分层现象。溶剂的沸点越高，沸腾时溶解力越强，对于高熔点物质，最好选高沸点溶剂。 含有羟基、氨基而且熔点不太高的物质尽量不选择含氧溶剂。因为溶质与溶剂形成分子间氢键后很难析出。 含有氧、氮的物质尽量不选择醇做溶剂，原因同上。 溶质和溶剂极性不要相差太悬殊。水&gt;甲酸&gt;甲醇&gt;乙酸&gt;乙醇&gt;异丙醇&gt;乙腈&gt;DMSO&gt;DMF&gt;丙酮&gt;HMPA&gt;CH2Cl2&gt;吡啶&gt;氯仿&gt;氯苯&gt;THF&gt;二氧六环&gt;乙醚&gt;苯&gt;甲苯&gt;CCl4&gt;正辛烷&gt;环己烷&gt;石油醚 使用纯溶剂不适合时，可以采用混合溶剂法:用过量热的良溶剂溶解，加热，缓慢加入不良溶剂至有浑浊，静置冷却到析出固体。实验室常用的配伍是乙酸乙酯和石油醚。溶剂的筛选在试管中加入少量待结晶物，加入0.5mL根据上述规律所选择溶剂，加热沸腾几分钟，看溶质是否溶解。若溶解，用自来水冲试管外测，看是否有晶体析出。如果长时间加热仍有不溶物，可以静置试管片刻并用冷水冷却试管（勿摇动）。如果有物质在上层清液中析出，表示还可以增加一些溶解。若稍微浑浊，表示溶剂溶解度太小；若没有任何变化，说明不溶的固体是一种东西，已溶物质又非常易溶，不易析出。 重结晶常规操作 加热法：在锥形瓶或圆底烧瓶中加入溶质和一定溶剂, 装上球冷, 加热10分钟，若仍有不溶物, 继续从冷凝管上口补加溶剂至完全溶解再补加过量30％溶剂。滴加不良溶剂, 至出现混浊(必要的时候加入晶种)撤除加热, 自然冷却到室温（不要极速冷冻降温）或者更低温度，过滤得固体。 常温法：用可溶溶剂使固体正好溶解，再缓慢滴加不良溶剂, 至固体缓慢析出。 减少溶剂降温法：用低沸点溶剂（常用的是乙醚）使固体刚溶剂, 用水泵抽真空, 使溶剂缓慢减少, 同时温度会降低, 固体慢慢析出。 小Tips 溶剂的沸点最好比被结晶物质的熔点低50℃。否则易产生溶质液化分层现象。 含有羟基、氨基而且熔点不太高的物质尽量不选择含氧溶剂。因为溶质与溶剂形成分子间氢键后很难析出。 过柱预纯化，粗分离后再结晶，这样的话重结晶成功率会大大提高。 不要轻易冷冻，自然降温得到固体纯度会大大提高。 晶种的取得，用玻璃棒沾一滴溶液，挥干。","categories":[{"name":"化学","slug":"化学","permalink":"http://yoursite.com/categories/化学/"}],"tags":[{"name":"实验操作","slug":"实验操作","permalink":"http://yoursite.com/tags/实验操作/"}]},{"title":"萃取操作基础","slug":"18-1-20-CQ","date":"2018-01-19T20:18:26.000Z","updated":"2018-01-20T10:28:30.354Z","comments":true,"path":"2018/01/20/18-1-20-CQ/","link":"","permalink":"http://yoursite.com/2018/01/20/18-1-20-CQ/","excerpt":"","text":"原理利用物质在两种不互溶（或微溶）溶剂中溶解度或分配比的不同来达到分离提纯目的。 萃取溶剂的选择 萃取溶剂的选择，应根据被萃取化合物的溶解度而定，同时要易于和溶质分开，最好用低沸点溶剂。 一般难溶于水的物质用石油醚等萃取；较易溶者，用乙醚等萃取；易溶于水的物质用乙酸乙酯等萃取。 每次使用萃取溶剂的体积一般是被萃取液体的1/5～1/3，两者的总体 积不应超过分液漏斗总体积的2/3。 乳化和破乳在萃取时常常出现不分层和乳化的现象，可以通过以下几种情况进行解决： 长时间静置； 加入适当的物质，使其密度差增大，对于水相，通常加入无机盐； 因表面活性剂存在而形成的乳化，改变溶液的pH往往能使其分层； 因碱性而产生乳化，可加入少量酸破坏； 因少量悬浮固体引起的乳化，可将乳浊液缓慢过滤，过滤时在漏斗里铺上一层吸附剂(硅酸镁、氧化铝、硅胶)，则效果更好; 因两种溶剂（水与有机溶剂）能部分互溶而发生乳化，可加入少量电解质如氯化钠等，利用盐析作用加以破坏; 对于顽固的乳化，还可用离心分离，也可加热，或向有机溶剂中加入极性溶剂（如醇类或丙酮）以改变两相的表面张力。 几种特殊的有机萃取溶剂 溶剂 性质 正丁醇 不溶于水，具有小分子醇和大分子醇的共同特点。常用从水中萃取大极性物质 2-丁醇 适宜从缓冲液中提取水溶性物质 乙酸丁酯 性质介于小分子和大分子酯之间，在水中的溶解性极小，可从水中萃取有机化合物，尤其是氨基酸类化合物 异丙醚 性质介于小分子和大分子之间，极性相对较小，在水中的溶解度较小，很适宜从磷酸盐缓冲溶液中提取羧酸 在结束阶段进行盐洗（饱和NaCl溶液）此操作有利于干扰乳化，并且可以除去溶于有机相中的水，起到“干燥”有机层的作用。 干燥有机层将有机溶液和水相分离之后，在有机相中加入干燥剂以除去微量的水。通常用高效快速的MgSO4，但MgSO4有轻微的酸性；或用Na2SO4，它的干燥速度稍慢，效率较低，但Na2SO4为中性。这些化合物可以和残留在有机溶液中的水结合，作用后形成团块。加入的干燥剂要适量，只要有一些干燥剂不再结块，说明可以不用再加入干燥剂了。 在得到实验结果前，有机相、水相、不明固体一律不允许丢弃。在得到实验结果前，有机相、水相、不明固体一律不允许丢弃。在得到实验结果前，有机相、水相、不明固体一律不允许丢弃。 重要的事情说三遍！！！","categories":[{"name":"化学","slug":"化学","permalink":"http://yoursite.com/categories/化学/"}],"tags":[{"name":"实验操作","slug":"实验操作","permalink":"http://yoursite.com/tags/实验操作/"}]},{"title":"TLC薄层析基础","slug":"18-1-20-TLC","date":"2018-01-19T19:51:00.000Z","updated":"2018-01-26T11:10:10.872Z","comments":true,"path":"2018/01/20/18-1-20-TLC/","link":"","permalink":"http://yoursite.com/2018/01/20/18-1-20-TLC/","excerpt":"","text":"原理根据吸附剂对对样品中各组分吸附能力不同，及展开剂对它们的解吸附能力的不同，使各组分达到分离的目的。 反应液的取样 一般极性体系 强极性溶剂体系 需要淬灭的体系 强碱、酸性环境 可以直接取样，也可以稀释后取样 最好简单后处理（加水和有机溶剂萃取）以后取样 处理（如加水或酸和有机溶剂）后取样 最好中和后取样 TLC展开剂常用展开剂极性大小顺序：石油醚 &lt; 二氯甲烷 &lt; 乙醚 &lt; 四氢呋喃 &lt; 乙酸乙酯 &lt; 丙酮 &lt; 正丙醇 &lt; 甲醇 &lt; 水一般极性的化合物常用PE(石油醚)/EA(乙酸乙酯)体系极性较大的化合物常用DCM(二氯甲烷)/CH3OH体系另外常用的混合体系:PE / DCM，PE / Acetone，Ether / DCM，EA / DCM，EA / CH3OH 显色剂 一看、首先在日光下观察，划出有色物质的斑点位置 二照、在紫外灯下观察有无暗斑或荧光斑点 三碘、大部分有机物会吸附碘可逆的产生棕色或黄色斑点 四显、既无色又无紫外吸收的物质，可以用显色剂显色 TLC的顺序TLC时一般点三个点，一个点原料，一个点原料+产物，一个点产物。当最后处理完成时还需要点一下纯品，以确保我们在前面判断反应进程的点真的是产品。","categories":[{"name":"化学","slug":"化学","permalink":"http://yoursite.com/categories/化学/"}],"tags":[{"name":"实验操作","slug":"实验操作","permalink":"http://yoursite.com/tags/实验操作/"}]},{"title":"并查集算法详解","slug":"18-1-18-BCJ","date":"2018-01-17T15:58:20.000Z","updated":"2018-02-01T02:17:27.105Z","comments":true,"path":"2018/01/17/18-1-18-BCJ/","link":"","permalink":"http://yoursite.com/2018/01/17/18-1-18-BCJ/","excerpt":"","text":"题目背景假如你身处于一个大家族，然而只知道数个关系对，也就是说只知道A和B是亲戚，B和C是亲戚，诸如此类，现在问你给出的任意两个人之间是不是亲戚。 思路解析初步看这道题的时候感觉是一道图论题，可以先构筑一个相关的图，然后再通过DFS找出它的每一个连通子图，最后只需要判断两个人在不在同一个连通子图就可以了。然而这么做的一个大问题就是复杂度太高，所需要的空间也太大。退而求其次，其实这道题也只是一个关于分离集合(并查集)的操作的问题。 并查集并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。并查集由一个整数型的数组和两个函数构成。数组pre[]记录了每个点的前导点是什么，函数find是查找，join是合并。先上代码：123456789101112131415161718192021int pre[1000];int find(int x) //查找根节点&#123; int r = x; while ( pre[r] != r ) //返回根节点r r=pre[r]; int i = x,j; while( i != r ) //路径压缩 &#123; j = pre[i]; //在改变上级之前用临时变量j记录下他的值 pre[i] = r ; //把上级改为根节点 i = j; &#125; return r;&#125;void join(int x,int y) //判断x y是否连通，&#123; int fx=find(x),fy=find(y); if(fx!=fy) //如果已经连通，就不用管了 pre[fx]=fy; //如果不连通，就把它们所在的连通分支合并起,&#125; 首先将每个人的pre都设置为他自己，也就是说任意两个人之间都不认识。然后输入“边”，对于边的两个端点分别查找他所属的集合领导。在find语句中首先是不停的寻找该点的前导点，直到该点的前导点是他自己，此时这个点便为根节点r。但是如果每一个点都像这样向前遍历的话所需要的时间也是蛮多的，我们希望对于所有已经找过一次根节点的点的pre都能直接是他的根节点，那样才是最节省时间的，毕竟这个树状结构只有两层。因此我们接下来进行路径压缩，开始从当前点记录，如果现在的这个点不是他的根节点r的话那么我们就将该点的pre设置为r，然后再次对他的原pre去遍历，直到这个点是他的根节点r。最后我们返回他的根节点。返回了根节点之后就需要进行对比，如果两个点的根节点不是同一个点的话那么我们就将其中一个根节点的pre设置为另一个根节点。那样他们两个集合就合并在一起了。 相关例题HD1232 HD5441","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"原创","slug":"计算机/原创","permalink":"http://yoursite.com/categories/计算机/原创/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"集合","slug":"集合","permalink":"http://yoursite.com/tags/集合/"}]},{"title":"拓扑排序算法","slug":"18-1-16-topo","date":"2018-01-17T05:10:48.000Z","updated":"2018-01-21T10:47:39.097Z","comments":true,"path":"2018/01/17/18-1-16-topo/","link":"","permalink":"http://yoursite.com/2018/01/17/18-1-16-topo/","excerpt":"","text":"拓扑排序是一种将有向图中的顶点以线性方式进行排序。即对于任何连接自顶点u到顶点v的有向边uv，在最后的排序结果中，顶点u总是在顶点v的前面。比较经典的例子就是选课，在选择一门高年级课之前你需要先上过这门课的基础课程。比如你在上《高等有机化学》之前必须要先修过《基础有机化学》这门课。在图中的表达就是《基础有机化学》指向《高等有机化学》，指向谁就是要后修哪门课。 偏序和全序这两个是离散数学的概念（mmp我们不上这门课），偏序的意思就是对任意两点不管他们有没有先后关系，只要不存在矛盾关系即为偏序的意义。例如，A -&gt; B -&gt; C -&gt; A就不是偏序的。而全序是偏序的一种特殊情况，即为任意两个点要有明确的关系。例如 A -&gt; B -&gt; C -&gt; A和A -&gt; D -&gt; C -&gt; A其中 C 和 D 就没有明确的前后顺序，则不能说它是满足全序的，只是满足偏序的情况。对于一种排序算法，我们的评价指标之一就是它是否稳定，即相同的元素出现顺序有没有被改变。比如我们说快排是不稳定的排序，就是因为它无法判断相同值的元素的顺序。而比较稳定的排序，比如冒泡、插排等，它们在排序的时候，对于相同值的元素还会比较一个潜在的条件，也就是这个元素在队列中的位置。之所以要提到这两个概念，就是因为如果一个图的所有点都满足全序的条件，那么这个图的拓扑排序只会有一种结果。 算法实现以下是关于拓扑排序的一段伪代码：1234567891011121314151617S:初始图中入度为0的顶点的集合L:拓扑排序的结果while(S不为空)&#123; 从S中取出一个点n; 将n加入L; for (所有与n相连的点) &#123; 在m的入度中删除一条边; if (m的入度为0) 将m加入S; &#125;&#125;if (图中仍有边) return error; (证明其中存在至少一个环路)else return L; 拓扑排序和哈密顿路径对于一个DAG(Directed Acyclic Graph，有向无环图)，若其中的任意两点都存在可以直接确定的先后关系时，那么它的拓扑排序是唯一的，因为它们形成了全序的关系。图中是否存在哈密顿路径的关键在于确定图中的顶点是否存在全序的关系。因此只要设计一种算法遍历图中的所有点对，验证它们之间有确定的先后关系，那么我们就可以确定图中是有哈密顿路径的。但是这种算法效率太低，其原因就是没有用到传递性。以比较1,2,3三个整数为例，按照之前的思想，我们分别对(1,2)，(2,3)，(1,3)进行比较，这样需要三次比较，但是1和3的那次比较明显是多余的。为了能用上传递性的规则，我们可以先进行拓扑排序，然后再依次比较相邻的顶点是否具有一致的前后关系。若满足该条件，那么基本可以确定在这个图中是含有哈密顿路径的，反之则没有。 相关例题 HDOJ 5438","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"原创","slug":"计算机/原创","permalink":"http://yoursite.com/categories/计算机/原创/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"图论入门（不定期更新）","slug":"2018-1-17-TLRM","date":"2018-01-17T04:27:55.000Z","updated":"2018-01-22T06:03:03.298Z","comments":true,"path":"2018/01/17/2018-1-17-TLRM/","link":"","permalink":"http://yoursite.com/2018/01/17/2018-1-17-TLRM/","excerpt":"","text":"概述图是一种比树和数组更复杂的数据结构，一般来说由顶点和边组成。通过边的连通形式的不同可以简单分类为无向图和有向图 图的储存对于绝大部分算法题都需要记录下边的具体信息，故此就有了两种储存方式。第一种即为通过邻接表矩阵来记录对于顶点Vi和顶点Vj，若有边，则(Vi,Vj)=1，否则(Vi,Vj)=0。若该图是一个无向图，那么它的邻接矩阵一定是以对角线为轴对称。这种储存方式虽然很一目了然，但是当这个图中具有n个点时，需要的空间为n²个位置来储存是否有连边同样的，如果用邻接表来储存图中边的信息，如下： 可以看到邻接表的实质其实就是链式储存。不过其实我觉得开一个vector数组也是完全ok的。 常用概念 顶点的度，与顶点i相关联的边的数量，记为D(i)。在有向图中还会分别记为入度ID和出度OD，这两个概念在拓扑排序中会有应用。 边数较少的叫做稀疏图，边数较多则叫稠密图。 有时边是带有权值的，这个权值可以表示从一个顶点到另一个顶点的距离、代价、耗费等。这样的图也称为带权图。 无环图：没有环的图(acyclic graph)。在有向图中，那就是有向无环图。 如果在图中任意两个点都存在路径，那么称其为连通图。 衍生概念 欧拉回路和欧拉路径将图中的所有路径走过恰好一次，那么该路径称为欧拉路径。相应的，如果这条路径是一条回路，那么称之为欧拉回路。 一个无向图存在欧拉通路的条件：G为连通图，并且G仅有两个奇度结点（度数为奇数的顶点）或者无奇度结点。 一个有向图存在欧拉通路的条件：D为有向图，D的基图连通，并且所有顶点的出度与入度都相等；或者除两个顶点外，其余顶点的出度与入度都相等，而这两个顶点中一个顶点的出度与入度之差为1，另一个顶点的出度与入度之差为-1。 一个无向图存在欧拉回路的条件：连通图中所有顶点都是偶数度。 一个有向图存在欧拉回路的条件：连通图中所有的顶点出度=入度。 哈密顿回路和哈密顿路径将图中的所有节点走过恰好一次，那么该路径称为哈密顿路径。相应的，如果这条路径是一条回路，那么称之为哈密顿回路。 未完待续","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"原创","slug":"计算机/原创","permalink":"http://yoursite.com/categories/计算机/原创/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"}]},{"title":"三种最短路径算法综述","slug":"2018-1-16-ZDLJ","date":"2018-01-16T06:12:04.000Z","updated":"2018-01-31T07:05:59.186Z","comments":true,"path":"2018/01/16/2018-1-16-ZDLJ/","link":"","permalink":"http://yoursite.com/2018/01/16/2018-1-16-ZDLJ/","excerpt":"","text":"从雪晴大佬那里转载来的，虽然不太懂，但只要低头就可以了。ORZ(天依蓝) 1.最短路径算法介绍问题解释：从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径解决问题的算法：Floyd算法Dijkstra算法SPFA算法2.Floyd算法弗洛伊德算法是解决任意两点间的最短路径的一种算法，可以正确处理有向图或有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。假设图中顶点个数为N，则需要对二维数组a进行N次更新。更新前，a[i][j]代表从顶点i到顶点j的距离，如果i和j不相邻则a[i][j]=∞，顶点b[i][j]则为j的值。接下来对数组a进行N次更新。第一次更新时，取第一个点为中介点，则i——①——j的距离可以表示为a[i][1]+a[1][j],如果这个值小于a[i][j]，就把a[i][j]的值更新为a[i][1]+a[1][j]，。同理，第k次更新时，如果 a[i][j] &gt; a[i][k]+a[k][j] ，就更新a[i][j]=a[i][k]+a[k][j]贴个代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstring&gt;#define N 999999using namespace std;int main(){ int n,m; int point1,point2,dis; int a[100][100]; memset(a,N,sizeof(a)); cin&gt;&gt;n&gt;&gt;m; //n 顶点个数，m 边数 for(int i=1;i&lt;=n;i++) a[i][i]=0; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;point1&gt;&gt;point2&gt;&gt;dis; a[point1][point2]=dis; } for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(a[i][j]&gt;a[i][k]+a[k][j]) a[i][j]=a[i][k]+a[k][j]; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) cout&lt;&lt;a[i][j]&lt;&lt;’ ‘; cout&lt;&lt;endl; } return 0;}3.Dijkstra算法迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单元最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点。然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。（不会贴图 先不贴了下面是代码 （算法部分123456789101112131415161718192021222324252627void Dijk()//我们这里起点为1号编码点。我们这里的d[]表示从起点到这个点需要的权值。w[a][b]表示点a到点b这条边的权值.{ int v, tmp; memset(vis, 0, sizeof(vis)); for (int i=1; i&lt;=n; i++) d[i] = w[1][i];//对于起点的初始化 d[1] = 0; vis[1] = 1; for (int i=1; i&lt;=n; i++)//控制连接点的次数，例如上图，九个点，就循环九次。 { tmp = N;//这里N表示无穷大。 for (int j=1; j&lt;=n; j++) { if (tmp&gt;d[j] &amp;&amp; !vis[j]) { tmp = d[j]; v = j; } }//每次我们都找到距离起点最近的点v vis[v] = 1; for (int k=1; k&lt;=n; k++) { if(!vis[k]) d[k]=min(d[k],d[v]+w[v][k]); } }}3.SPFA算法SPFA算法是求解单源最短路径问题的一种算法，由理查德·贝尔曼（Richard Bellman） 和 莱斯特·福特 创立的。有时候这种算法也被称为 Moore-Bellman-Ford 算法，因为 Edward F. Moore 也为这个算法的发展做出了贡献。它的原理是对图进行V-1次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达 O(VE)。但算法可以进行若干种优化，提高了效率。我们用数组dis记录每个结点的最短路径估计值，用邻接表或邻接矩阵来存储图G。我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止我们要知道带有负环的图是没有最短路径的，所以我们在执行算法的时候，要判断图是否带有负环，方法有两种：开始算法前，调用拓扑排序进行判断（较为费时）如果某个点进入队列的次数超过N次则存在负环（N为图的顶点数）(还没学完，学完再补坑","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"膜晴","slug":"计算机/膜晴","permalink":"http://yoursite.com/categories/计算机/膜晴/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"}]},{"title":"后处理方法简单汇总","slug":"18-1-15-HCL","date":"2018-01-15T08:18:41.000Z","updated":"2018-01-16T07:27:11.080Z","comments":true,"path":"2018/01/15/18-1-15-HCL/","link":"","permalink":"http://yoursite.com/2018/01/15/18-1-15-HCL/","excerpt":"","text":"有机酸碱性化合物的分离提纯 具有酸碱性基团的有机化合物，可以得失质子形成离子化合物，而离子化合物与原来的母体化合物具有不同的物理化学性质。碱性化合物用有机酸或无机酸处理得到胺盐，酸性化合物用有机碱或无机碱处理得到钠盐或有机盐。根据有机化合物酸碱性的强弱，有机、无机酸碱一般为甲酸、乙酸、盐酸、硫酸、磷酸。碱为三乙胺、氢氧化钠、氢氧化钾、碳酸钠、碳酸氢钠等。在一般情况下，离子化合物在水中具有相当大的溶解性，而在有机溶剂中溶解度很小，同时活性碳只能够吸附非离子型的杂质和色素。利用以上的这些性质可对酸碱性有机化合物进行提纯。以上性质对所有酸碱性化合物并不通用，一般情况下，分子中酸碱性基团分子量所占整个分子的分子量比例越大，则离子化合物的水溶性就越大，分子中含有的水溶性基团例如羟基越多，则水溶性越大，因此，以上性质适用于小分子的酸碱化合物。对于大分子的化合物，则水溶性就明显降低。 酸碱性基团包括氨基。酸性基团包括：酰氨基、羧基、酚羟基、磺酰氨基、硫酚基、1，3－二羰基化合物等等。值得注意的是，氨基化合物一般为碱性基团，但是在连有强吸电子基团时就变为酸性化合物，例如酰氨基和磺酰氨基化合物，这类化合物在氢氧化钠、氢氧化钾等碱作用下就容易失去质子而形成钠盐。 中合吸附法：将酸碱性化合物转变为离子化合物，使其溶于水，用活性碳吸附杂质后过滤，则除去了不含酸碱性基团的杂质和机械杂质，再加酸碱中合回母体分子状态，这是回收和提纯酸碱性产品的方法。由于活性碳不吸附离子，故有活性碳吸附造成的产品损失忽劣不计。 中和萃取法：是工业过程和实验室中常见的方法，它利用酸碱性有机化合物生成离子时溶于水而母体分子状态溶于有机溶剂的特点，通过加入酸碱使母体化合物生成离子溶于水实现相的转移而用非水溶性的有机溶剂萃取非酸碱性杂质，使其溶于有机溶剂从而实现杂质与产物分离的方法。 成盐法：对于非水溶性的大分子有机离子化合物，可使有机酸碱性化合物在有机溶剂中成盐析出结晶来，而非成盐的杂质依然留在有机溶剂中，从而实现有机酸碱性化合物与非酸碱性杂质分离，酸碱性有机杂质的分离可通过将析出的结晶再重结晶，从而将酸碱性有机杂质分离。对于大分子的有机酸碱化合物的盐此时还可以采用水洗涤除去小分子的酸碱化合物已经成盐且具有水溶性的杂质。 对于水溶性的有机离子化合物，可在水中成盐后，将水用共沸蒸馏或直接蒸馏除去，残余物用有机溶剂充分洗涤几次，从而将杂质与产品分离。以上三种方法并不是孤立的，可根据化合物的性质和产品质量标准的要求，采用相结合的方法，尽量得到相当纯度的产品。 几种特殊的有机萃取溶剂 正丁醇：大多数的小分子醇是水溶性的，例如甲醇、乙醇、异丙醇、正丙醇等。大多数的高分子量醇是非水溶性的，而是亲脂性的能够溶于有机溶剂。但是中间的醇类溶剂例如正丁醇是一个很好的有机萃取溶剂。正丁醇本身不溶于水，同时又具有小分子醇和大分子醇的共同特点。它能够溶解一些能够用小分子醇溶解的极性化合物，而同时又不溶于水。利用这个性质可以采用正丁醇从水溶液中萃取极性的反应产物 丁酮：性质介于小分子酮和大分子酮之间。不像丙酮能够溶于水，丁酮不溶于水，可用来从水中萃取产物 乙酸丁酯：性质介于小分子和大分子酯之间，在水中的溶解度极小，不像乙酸乙酯在水中有一定的溶解度，可从水中萃取有机化合物，尤其是氨基酸的化合物，因此在抗生素工业中常用来萃取头孢、青霉素等大分子含氨基酸的化合物 异丙醚与特丁基叔丁基醚：性质介于小分子和大分子醚之间，两者的极性相对较小，类似于正己烷和石油醚，二者在水中的溶解度较小。可用于极性非常小的分子的结晶溶剂和萃取溶剂。也可用于极性较大的化合物的结晶和萃取溶剂。 做完反应后，应该首先采用萃取的方法，首先除去一部分杂质，这是利用杂质与产物在不同溶剂中的溶解度不同的性质 稀酸的水溶液洗去一部分碱性杂质。例如，反应物为碱性，而产物为中性，可用稀酸洗去碱性反应物。例如胺基化合物的酰化反应。 稀碱的水溶液洗去一部分酸性杂质。反应物为酸性，而产物为中性，可用稀碱洗去酸性反应物。例如羧基化合物的酯化反应。 用水洗去一部分水溶性杂质。例如，低级醇的酯化反应，可用水洗去水溶性的反应物醇。 如果产物要从水中结晶出来，且在水溶液中的溶解度又较大，可尝试加入氯化钠、氯化铵等无机盐，降低产物在水溶液中的溶解度－盐析的方法。 有时可用两种不互溶的有机溶剂作为萃取剂，例如反应在氯仿中进行，可用石油醚或正己烷作为萃取剂来除去一部分极性小的杂质，反过来可用氯仿萃取来除去极性大的杂质。 两种互溶的溶剂有时加入另外一种物质可变的互不相容，例如，在水作溶剂的情况下，反应完毕后，可往体系中加入无机盐氯化钠，氯化钾使水饱和，此时加入丙酮，乙醇，乙腈等溶剂可将产物从水中提取出来。 结晶与重结晶的方法 基本原理是利用相似相容原理。即极性强的化合物用极性溶剂重结晶，极性弱的化合物用非极性溶剂重结晶。对于较难结晶的化合物，例如油状物、胶状物等有时采用混合溶剂的方法，但是混合溶剂的搭配很有学问，有时只能根据经验。一般采用极性溶剂与非极性溶剂搭配，搭配的原则一般根据产物与杂质的极性大小来选择极性溶剂与非极性溶剂的比例。若产物极性较大，杂质极性较小则溶剂中极性溶剂的比例大于非极性溶剂的比例；若产物极性较小，杂质极性较大，则溶剂中非极性溶剂的比例大于极性溶剂的比例。较常用的搭配有：醇－石油醚，丙酮－石油醚，醇－正己烷，丙酮－正己烷等。但是如果产物很不纯或者杂质与产物的性质及其相近，得到纯化合物的代价就是多次的重结晶，有时经多次也提不纯。这时一般较难除去的杂质肯定与产物的性质与极性及其相近。除去杂质只能从反应上去考虑了。 水蒸气蒸馏、减压蒸馏与精馏的方法 这是提纯低熔点化合物的常用方法。一般情况下，减压蒸馏的回收率相应较低，这是因为随着产品的不断蒸出，产品的浓度逐渐降低，要保证产品的饱和蒸汽压等于外压，必须不断提高温度，以增加产品的饱和蒸汽压，显然，温度不可能无限提高，即产品的饱和蒸汽压不可能为零，也即产品不可能蒸净，必有一定量的产品留在蒸馏设备内被设备内的难挥发组分溶解，大量的斧残既是证明。 共沸蒸馏不仅适用于产品分离过程，也适用于反应物系的脱水、溶剂的脱水、产品的脱水等。它比分子筛、无机盐脱水工艺具有设备简单、操作容易、不消耗其它原材料等优点。例如：在生产氨噻肟酸时，由于分子中存在几个极性的基团氨基、羧基等，它们能够和水、醇等分子形成氢键，使氨噻肟酸中存在大量的游离及氢键的水，如采用一般的真空干燥等干燥方法，不仅费时，也容易造成产物的分解，这时可采用共沸蒸馏的方法将水分子除去，具体的操作为将氨噻肟酸与甲醇在回流下搅拌几小时，可将水分子除去，而得到无水氨噻肟酸。又比如，当分子中存在游离的或氢键的甲醇时，可用另外一种溶剂，例如正己烷、石油醚等等，进行回流，可除去甲醇。可见共沸蒸馏在有机合成的分离过程中占有重要的地位。 超分子的方法，利用分子的识别性来提纯产物 脱色的方法 一般采用活性炭、硅胶、氧化铝等。活性炭吸附非极性的化合物与小分子的化合物，硅胶与氧化铝吸附极性强的与大分子的化合物，例如焦油等。对于极性杂质与非极性杂质同时存在的物系，应将两者同时结合起来。比较难脱色的物系，一般用硅胶和氧化铝就能脱去。对于酸碱性化合物的脱色，有时比较难，当将酸性化合物用碱中和形成离子化合物而溶于水中进行脱色时，除了在弱碱性条件下脱色一次除去碱性杂质外，还应将物系逐渐中和至弱酸性，再脱色一次除去酸性杂质，这样就将色素能够完全脱去。同样当将碱性化合物用酸中和至弱碱性溶于水进行脱色时，除了在弱酸性条件下脱色一次除去酸性杂质外，还应将物系逐渐中和至弱碱性，再脱色一次除去碱性杂质。","categories":[{"name":"化学","slug":"化学","permalink":"http://yoursite.com/categories/化学/"}],"tags":[{"name":"后处理","slug":"后处理","permalink":"http://yoursite.com/tags/后处理/"},{"name":"实验操作","slug":"实验操作","permalink":"http://yoursite.com/tags/实验操作/"}]},{"title":"BST(二叉搜索树)","slug":"18-1-15-BST","date":"2018-01-15T05:09:54.000Z","updated":"2018-01-16T03:08:18.625Z","comments":true,"path":"2018/01/15/18-1-15-BST/","link":"","permalink":"http://yoursite.com/2018/01/15/18-1-15-BST/","excerpt":"","text":"二叉搜索树是一种树的类型。它的左子树若不为空，则其中所有节点的值都必定小于父节点；同理若它的右子树不为空，其中所有的节点也必定大于父节点。如下所示，12的左子树的节点数值全部比12小，右子树节点的数值全部比12大。 构造二叉搜索树针对于构造二叉搜索树，先确定其根节点，后进行如下操作 比较节点(root)与待插入值的大小：若root较大，则将root赋值为该节点的左子节点；若root较小，则将root赋值为该节点的右子节点。 若该节点没有的左(右)子节点为0，也就是没有子节点。那么将此待插入值定义为root的子节点。 搜索二叉搜索树因为二叉搜索树一定满足上面提到的条件，故而在搜索时应先比较大小，若小于当前节点则向它的左子树去搜索，若大于当前节点则向它的右子树去搜索，直到当前节点等于我们要找的节点。 相关题目HDOJ 5444","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"原创","slug":"计算机/原创","permalink":"http://yoursite.com/categories/计算机/原创/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-15T02:18:16.970Z","updated":"2018-01-15T06:49:11.099Z","comments":true,"path":"2018/01/15/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}